<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />




<title>Arduino</title>

<script src="site_libs/header-attrs-2.8/header-attrs.js"></script>
<script src="site_libs/jquery-1.11.3/jquery.min.js"></script>
<meta name="viewport" content="width=device-width, initial-scale=1" />
<link href="site_libs/bootstrap-3.3.5/css/cosmo.min.css" rel="stylesheet" />
<script src="site_libs/bootstrap-3.3.5/js/bootstrap.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/html5shiv.min.js"></script>
<script src="site_libs/bootstrap-3.3.5/shim/respond.min.js"></script>
<style>h1 {font-size: 34px;}
       h1.title {font-size: 38px;}
       h2 {font-size: 30px;}
       h3 {font-size: 24px;}
       h4 {font-size: 18px;}
       h5 {font-size: 16px;}
       h6 {font-size: 12px;}
       code {color: inherit; background-color: rgba(0, 0, 0, 0.04);}
       pre:not([class]) { background-color: white }</style>
<script src="site_libs/navigation-1.1/tabsets.js"></script>
<link href="site_libs/highlightjs-9.12.0/default.css" rel="stylesheet" />
<script src="site_libs/highlightjs-9.12.0/highlight.js"></script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
    </style>

<style type="text/css">code{white-space: pre;}</style>
<script type="text/javascript">
if (window.hljs) {
  hljs.configure({languages: []});
  hljs.initHighlightingOnLoad();
  if (document.readyState && document.readyState === "complete") {
    window.setTimeout(function() { hljs.initHighlighting(); }, 0);
  }
}
</script>








<style type = "text/css">
.main-container {
  max-width: 940px;
  margin-left: auto;
  margin-right: auto;
}
img {
  max-width:100%;
}
.tabbed-pane {
  padding-top: 12px;
}
.html-widget {
  margin-bottom: 20px;
}
button.code-folding-btn:focus {
  outline: none;
}
summary {
  display: list-item;
}
pre code {
  padding: 0;
}
</style>


<style type="text/css">
.dropdown-submenu {
  position: relative;
}
.dropdown-submenu>.dropdown-menu {
  top: 0;
  left: 100%;
  margin-top: -6px;
  margin-left: -1px;
  border-radius: 0 6px 6px 6px;
}
.dropdown-submenu:hover>.dropdown-menu {
  display: block;
}
.dropdown-submenu>a:after {
  display: block;
  content: " ";
  float: right;
  width: 0;
  height: 0;
  border-color: transparent;
  border-style: solid;
  border-width: 5px 0 5px 5px;
  border-left-color: #cccccc;
  margin-top: 5px;
  margin-right: -10px;
}
.dropdown-submenu:hover>a:after {
  border-left-color: #adb5bd;
}
.dropdown-submenu.pull-left {
  float: none;
}
.dropdown-submenu.pull-left>.dropdown-menu {
  left: -100%;
  margin-left: 10px;
  border-radius: 6px 0 6px 6px;
}
</style>

<script type="text/javascript">
// manage active state of menu based on current page
$(document).ready(function () {
  // active menu anchor
  href = window.location.pathname
  href = href.substr(href.lastIndexOf('/') + 1)
  if (href === "")
    href = "index.html";
  var menuAnchor = $('a[href="' + href + '"]');

  // mark it active
  menuAnchor.tab('show');

  // if it's got a parent navbar menu mark it active as well
  menuAnchor.closest('li.dropdown').addClass('active');

  // Navbar adjustments
  var navHeight = $(".navbar").first().height() + 15;
  var style = document.createElement('style');
  var pt = "padding-top: " + navHeight + "px; ";
  var mt = "margin-top: -" + navHeight + "px; ";
  var css = "";
  // offset scroll position for anchor links (for fixed navbar)
  for (var i = 1; i <= 6; i++) {
    css += ".section h" + i + "{ " + pt + mt + "}\n";
  }
  style.innerHTML = "body {" + pt + "padding-bottom: 40px; }\n" + css;
  document.head.appendChild(style);
});
</script>

<!-- tabsets -->

<style type="text/css">
.tabset-dropdown > .nav-tabs {
  display: inline-table;
  max-height: 500px;
  min-height: 44px;
  overflow-y: auto;
  border: 1px solid #ddd;
  border-radius: 4px;
}

.tabset-dropdown > .nav-tabs > li.active:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li.active:before {
  content: "&#xe258;";
  border: none;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open:before {
  content: "";
  font-family: 'Glyphicons Halflings';
  display: inline-block;
  padding: 10px;
  border-right: 1px solid #ddd;
}

.tabset-dropdown > .nav-tabs > li.active {
  display: block;
}

.tabset-dropdown > .nav-tabs > li > a,
.tabset-dropdown > .nav-tabs > li > a:focus,
.tabset-dropdown > .nav-tabs > li > a:hover {
  border: none;
  display: inline-block;
  border-radius: 4px;
  background-color: transparent;
}

.tabset-dropdown > .nav-tabs.nav-tabs-open > li {
  display: block;
  float: none;
}

.tabset-dropdown > .nav-tabs > li {
  display: none;
}
</style>

<!-- code folding -->




</head>

<body>


<div class="container-fluid main-container">




<div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="index.html"></a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav">
        <li>
  <a href="index.html">Inicio</a>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Contenido
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li class="dropdown-header">Unidades </li>
    <li>
      <a href="encuadre.html">Encuadre</a>
    </li>
    <li class="dropdown-header">Unidad 1</li>
    <li>
      <a href="U1.html">Introducción</a>
    </li>
    <li>
      <a href="U1A.html">Arduino</a>
    </li>
    <li>
      <a href="U1R.html">Raspberry Pi</a>
    </li>
    <li>
      <a href="U2.html">Unidad 2</a>
    </li>
    <li>
      <a href="U3.html">Unidad 3</a>
    </li>
  </ul>
</li>
<li class="dropdown">
  <a href="#" class="dropdown-toggle" data-toggle="dropdown" role="button" aria-expanded="false">
    Recursos 
     
    <span class="caret"></span>
  </a>
  <ul class="dropdown-menu" role="menu">
    <li class="dropdown-header">Unidad 1</li>
    <li>
      <a href="IE.html">Introducción a la Electrónica</a>
    </li>
    <li>
      <a href="CE.html">Componentes Electrónicos</a>
    </li>
    <li>
      <a href="PA.html">Programación en Arduino</a>
    </li>
    <li>
      <a href="PE.html">Prácticas de Electrónica</a>
    </li>
    <li class="dropdown-header">Unidad 2</li>
    <li class="dropdown-header">Unidad 3</li>
  </ul>
</li>
<li>
  <a href="contacto.html">Contacto</a>
</li>
      </ul>
      <ul class="nav navbar-nav navbar-right">
        
      </ul>
    </div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->

<div id="header">



<h1 class="title toc-ignore">Arduino</h1>

</div>

<div id="TOC">
<ul>
<li><a href="#introducción-al-microcontrolador">Introducción al microcontrolador</a>
<ul>
<li><a href="#pines-de-propósito-general-gpio">Pines de propósito general (GPIO)</a></li>
<li><a href="#voltaje-de-operación">Voltaje de operación</a></li>
<li><a href="#velocidad-de-operación">Velocidad de operación</a></li>
<li><a href="#resolución-del-convertidor-analógico-a-digital-adc.">Resolución del convertidor analógico a digital (ADC).</a></li>
<li><a href="#puertos-de-comunicación">Puertos de comunicación</a></li>
</ul></li>
<li><a href="#arduino">Arduino</a>
<ul>
<li><a href="#recursos-de-inicio">Recursos de inicio</a></li>
</ul></li>
<li><a href="#placa-arduino-uno">Placa Arduino UNO</a>
<ul>
<li><a href="#componentes">Componentes</a></li>
</ul></li>
<li><a href="#prácticas-con-arduino">Prácticas con Arduino</a>
<ul>
<li><a href="#práctica-01.-encender-un-led">Práctica 01. Encender un LED</a></li>
<li><a href="#ejercicio-propuesto-01">Ejercicio propuesto 01</a></li>
<li><a href="#práctica-02.-encender-varios-leds">Práctica 02. Encender varios leds</a></li>
<li><a href="#práctica-02-con-un-ciclo-for">Práctica 02 con un ciclo <em>for</em></a></li>
<li><a href="#práctica-03.-recibiendo-señal-de-un-botón">Práctica 03. Recibiendo señal de un botón</a></li>
<li><a href="#práctica-04.-lectura-serial-de-una-entrada-digital">Práctica 04. Lectura serial de una entrada digital</a></li>
<li><a href="#práctica-05.-introduciendo-datos-en-la-consola-serial">Práctica 05. Introduciendo datos en la consola serial</a></li>
<li><a href="#práctica-06.-encender-gradualmente-un-led">Práctica 06. Encender gradualmente un led</a></li>
<li><a href="#práctica-07.-introduciendo-un-potenciómetro">Práctica 07. Introduciendo un potenciómetro</a></li>
<li><a href="#práctica-08.-encendiendo-un-led-con-el-pot">Práctica 08. Encendiendo un led con el pot</a></li>
<li><a href="#práctica-09.-encendido-gradual-de-un-led-con-el-giro-de-un-pot">Práctica 09. Encendido gradual de un led con el giro de un pot</a></li>
<li><a href="#práctica-10.-encendiendo-un-motor-cd">Práctica 10. Encendiendo un motor CD</a></li>
<li><a href="#práctica-11.-controlando-un-motor-cd-con-un-potenciómetro">Práctica 11. Controlando un motor CD con un potenciómetro</a></li>
<li><a href="#práctica-12.-encender-un-led-en-ausencia-de-luz">Práctica 12. Encender un led en ausencia de luz</a></li>
<li><a href="#práctica-13.-detectando-movimiento">Práctica 13. Detectando movimiento</a></li>
<li><a href="#práctica-14.-midiendo-distancias">Práctica 14. Midiendo distancias</a></li>
<li><a href="#práctica-15.-pantallas-lcd">Práctica 15. Pantallas LCD</a></li>
</ul></li>
</ul>
</div>

<div id="introducción-al-microcontrolador" class="section level2">
<h2>Introducción al microcontrolador</h2>
<p>Al elegir trabajar con un microcontrolador deben tomarse en cuenta las siguientes especificaciones técnicas.</p>
<div id="pines-de-propósito-general-gpio" class="section level3">
<h3>Pines de propósito general (GPIO)</h3>
<p>Son las diferentes entradas y salidas con las que cuenta el microcontrolador, se emplean para obtener los valores de diferentes sensores, establecer comunicaciones con otros dispositivos y controlar elementos desde LED hasta motores de gran potencia. Pueden ser:</p>
<ul>
<li>Entradas y salidas digitales</li>
<li>Entradas analógicas</li>
<li>Salidas analógicas o PWM</li>
<li>Puertos de comunicación</li>
</ul>
<p>Con relación a los pines GPIO se debe considerar el número de cada tipo de pin que se requiere al seleccionar el microcontrolador para que este sea capaz de controlar todos los elementos.</p>
</div>
<div id="voltaje-de-operación" class="section level3">
<h3>Voltaje de operación</h3>
<p>Indica el tipo de alimentación que debe recibir el microcontrolador y los valores con los que operan sus pines de propósito general. Es importante conocer estos valores ya que de lo contario podrían dañarse componentes o bien no funcionar adecuadamente en caso de no respetarlos. Los valores más comunes son 3.3V y 5V de modo que si se opera con elementos de mayor consumo de energía se deberán utilizar etapas de potencia para controlar dichos elementos.</p>
</div>
<div id="velocidad-de-operación" class="section level3">
<h3>Velocidad de operación</h3>
<p>También se conoce como velocidad de reloj y se refiere a la frecuencia o rapidez con la que puede procesar las instrucciones. Se debe tomar en cuenta sobre todo para aplicaciones que requieran alta velocidad de procesamiento. Algunos de los valores más comunes son 16MHz, 80MHz y 120MHz.</p>
</div>
<div id="resolución-del-convertidor-analógico-a-digital-adc." class="section level3">
<h3>Resolución del convertidor analógico a digital (ADC).</h3>
<p>Se refiere a la precisión con la que el ADC entrega el resultado de convertir un valor analógico a su equivalente en digital. Algunos de los valores más comunes de resolución son 8 bits, 10 bits y 12 bits. Una de las mayores razones por las cuales se unen Arduino y Raspberry Pi es precisamente el utilizar sensores que solo entregan salida analógica, siendo convertida en digital para la comunicación con la Raspi, ya que ésta solo admite entrada digital.</p>
</div>
<div id="puertos-de-comunicación" class="section level3">
<h3>Puertos de comunicación</h3>
<p>Se refiere a los pines que sirven para comunicar dos o más dispositivos entre sí, bajo un protocolo de comunicación estandarizado. Los protocolos mayormente empleados son la comunicación serial, I2C y SPI/SSI.</p>
</div>
</div>
<div id="arduino" class="section level2">
<h2>Arduino</h2>
<p>Arduino es una plataforma de electrónica abierta para la creación de prototipos basada en software y hardware libre, flexibles y fáciles de usar. Se creó para artistas, diseñadores, aficionados y cualquier interesado en crear entornos u objetos interactivos.</p>
<p>Arduino puede tomar información del entorno a través de sus pines de entrada, para esto puede ser usada toda una gama de sensores y puede afectar aquello que le rodea controlando luces, motores y otros actuadores. El microcontrolador en la placa Arduino se programa mediante el lenguaje de programación Arduino (basado en Wiring) y el entorno de desarrollo Arduino IDE (basado en Processing). Los proyectos hechos con Arduino pueden ejecutarse sin necesidad de conectarlo a un ordenador, si bien tienen la posibilidad de hacerlo y comunicar con diferentes tipos de software.</p>
<p>Las placas pueden ser hechas a mano o comprarse montadas de fábrica; el software puede ser descargado de forma gratuita. Los ficheros de diseño de referencia (CAD) están disponibles bajo una licencia abierta, así pues cualquiera es libre de adaptarlos a sus necesidades.</p>
<div id="recursos-de-inicio" class="section level3">
<h3>Recursos de inicio</h3>
<p>A continuación les comparto unos enlaces donde podrán obtener ciertas aplicaciones que resultarán de bastante ayuda en el desarrollo con Arduino.</p>
<div id="arduino-ide" class="section level4">
<h4>Arduino IDE</h4>
<p>El primero es para acceder al entorno de desarrollo propiamente dicho: <a href="https://www.arduino.cc/en/Main/Software">Arduino IDE</a>. En ese sitio podrán encontrar las diferentes opciones existentes: la aplicación web (por si no desean instalar nada) y las versiones de instaladores para todos los sistemas operativos. Cabe mencionar que esta es la aplicación a utilizar si se cuenta con la tarjeta Arduino.</p>
</div>
<div id="fritzing" class="section level4">
<h4>Fritzing</h4>
<p>Es un programa que permite el diseño de circuitos electrónicos, por lo cual es bastante práctico para dibujar el prototipo del diagramado, ya que cuenta con representaciones de los dispositivos usuales e incluso, tarjetas <em>protoboard</em>. Resulta bastante útil si se desea representar y documentar circuitos de prueba reales, ya que incluso permite obtener el diagrama electrónico de los mismos. Puede obtenerse desde su <a href="https://fritzing.org/download/">página de descargas</a>.</p>
<p>*NOTA: Fritzing es software libre y eso no necesariamente implica que sea gratis. Anteriormente la descarga era totalmente libre y gratuita, pero desde la versión 0.9.4 de diciembre de 2019, comenzó a pedir un pago para poder obtenerla. Aún es posible acceder a Fritzing de manera gratuita, pero solo desde los repositorios de alguna distribución Linux.</p>
</div>
<div id="tinkercad" class="section level4">
<h4>TinkerCAD</h4>
<p>Es un sitio web que implementa un simulador de circuitos electrónicos, con la gran ventaja de que incluye a la placa Arduino UNO. Esto permite aprender a construir y programar circuitos electrónicos cuya base sea la placa como tal. Puede accederse por medio del siguiente enlace:</p>
<p><a href="https://www.tinkercad.com">TinkerCAD</a></p>
<p>La interfaz es bastante intuitiva. Baste ver la siguiente captura y unas cuantas anotaciones:</p>
<p><img src="images/090-uso-tinkercad.png" /></p>
<ol style="list-style-type: decimal">
<li><p>Botón de inicio, devuelve al listado de proyectos.</p></li>
<li><p>Nombre del circuito</p></li>
<li><p>Con este botón se gira el componente selecciona 45°</p></li>
<li><p>Centra el circuito en pantalla</p></li>
<li><p>Elimina el componente seleccionado, lo mismo puede hacerse con la tecla <code>Supr</code></p></li>
<li><p>Botones deshacer y rehacer</p></li>
<li><p>Agrega notas al circuito</p></li>
<li><p>Oculta el elemento seleccionado</p></li>
<li><p>Pantalla principal de edición</p></li>
<li><p>Muestra el código. Por defecto lo muestra en modo Bloques, pero puede seleccionarse entre los modos Bloques, Texto o Bloques+Texto</p></li>
<li><p>Inicia/termina la simulación</p></li>
<li><p>Filtra el listado de componentes</p></li>
<li><p>Muestra la vista de Circuito en la pantalla principal</p></li>
<li><p>Cambia a la vista Lista de componentes del circuito</p></li>
<li><p>Muestra las opciones de la cuenta de usuario</p></li>
<li><p>Permite compartir el circuito, ya sea como diagrama, imagen o para edición colaborativa</p></li>
<li><p>Cambia la manera en la que se visualizan los componentes en el listado</p></li>
<li><p>Listado de componentes</p></li>
</ol>
</div>
</div>
</div>
<div id="placa-arduino-uno" class="section level2">
<h2>Placa Arduino UNO</h2>
<p>Existe una cantidad decente de placas Arduino, unas enfocadas al audio, a la industria textil, etcétera. También existe un conjunto de añadidos conocidos como <em>shields</em> que le aportan a la placa capacidades de conexión wifi, ethernet, Bluetooth, GPS, GSM, entre otras. Para comenzar, nos enfocaremos únicamente en la placa UNO.</p>
<div id="componentes" class="section level3">
<h3>Componentes</h3>
<p>A continuación se muestran los componentes principales de la placa Arduino UNO:</p>
<p><img src="images/087-arduino.png" /></p>
<ol style="list-style-type: decimal">
<li><p>Botón de reinicio (reset)</p></li>
<li><p>Pines de entrada/salida digitales</p></li>
<li><p>Conector USB tipo AB</p></li>
<li><p>ATmega 16U2 encargado de la comunicación con la PC</p></li>
<li><p>LED naranja conectado al pin13</p></li>
<li><p>LED TX (Transmisor) y RX (Receptor) de la comunicación serial</p></li>
<li><p>LED verde de placa encendida</p></li>
<li><p>Cristal de cuarzo de 16Mhz</p></li>
<li><p>Regulador de voltaje</p></li>
<li><p>Microcontrolador ATmega 328, cerebro del Arduino</p></li>
<li><p>Conector hembra 2.1mm con centro positivo</p></li>
<li><p>Pines de voltaje y tierra</p></li>
<li><p>Entradas análogas</p></li>
</ol>
</div>
</div>
<div id="prácticas-con-arduino" class="section level2">
<h2>Prácticas con Arduino</h2>
<div id="práctica-01.-encender-un-led" class="section level3">
<h3>Práctica 01. Encender un LED</h3>
<p>Aprenderemos a activar una señal digital, con ella encenderemos un LED, y por medio de un temporizador dejaremos que permanezca así y lo apagaremos al transcurrir un segundo. También veremos una introducción a la estructura de un programa de Arduino.</p>
<div id="material" class="section level4">
<h4>Material</h4>
<ul>
<li><p>LED de cualquier color</p></li>
<li><p>Resistencia de mínimo 470<span class="math inline">\(\Omega\)</span></p></li>
<li><p>Arduino UNO</p></li>
<li><p>Cable rojo</p></li>
<li><p>Cable negro</p></li>
</ul>
</div>
<div id="circuito" class="section level4">
<h4>Circuito</h4>
<p>Armamos el siguiente circuito en formato físico o en TinkerCAD:</p>
<p><img src="images/088-circuito-01.png" /></p>
</div>
<div id="código" class="section level4">
<h4>Código</h4>
<p>En la interfaz de TinkerCAD damos clic en el botón <code>Código</code> y veremos que nos muestra un conjunto de bloques. En el menú contextual que dice llanamente <code>Bloques</code> seleccionamos <code>Texto</code>. Hacemos caso omiso de la advertencia que nos marca y veremos que, de no haber editado anteriormente, ya está el siguiente código escrito:</p>
<pre class="{c++}"><code>void setup()
{
  pinMode(13, OUTPUT);
}

void loop()
{
  digitalWrite(13, HIGH);
  delay(1000); // Wait for 1000 millisecond(s)
  digitalWrite(13, LOW);
  delay(1000); // Wait for 1000 millisecond(s)
}</code></pre>
<p>Damos clic en <code>Iniciar simulación</code> y deberíamos poder ver cómo el led enciende y apaga en intervalos de un segundo. Expliquemos el código, mencionando la recomendación de darle una ojeada a los recursos de la Unidad, más precisamente a la que se refiere a la <a href="https://luisemendoza.github.io/SE-UPGoP/PA.html">programación en Arduino</a>. Los comentarios se escriben antecedidos por un par de diagonales <code>//</code>.</p>
<pre class="{c++}"><code>void setup()   // Esto se ejecutará cada vez que el arduino encienda
{
  pinMode(13, OUTPUT);   // Configuramos el pin 13 como un pin con señal de salida
}

void loop()   // Esto es un ciclo, y se estará ejecutando mientras el arduino tenga energía
{
  digitalWrite(13, HIGH);   // Activamos la señal digital (1) y la mandamos al pin 13, led encendido
  delay(1000);   // mantenemos la señal activa por mil milisegundos (1 segundo)
  digitalWrite(13, LOW);   // Desactivamos la señal digital (0), led apagado
  delay(1000); // mantenemos la señal desactivada por mil milisegundos 
}

// Programa terminado</code></pre>
</div>
</div>
<div id="ejercicio-propuesto-01" class="section level3">
<h3>Ejercicio propuesto 01</h3>
<p>Con el mismo circuito, haga que el led se comporte lo más parecido posible a un estrobo. Sugerencia, juegue con los tiempos de encendido y apagado.</p>
</div>
<div id="práctica-02.-encender-varios-leds" class="section level3">
<h3>Práctica 02. Encender varios leds</h3>
<p>Ahora encenderemos y apagaremos secuencialmente tres leds, cada uno conectado a un pin específico. Por la parte del código, veremos cómo declarar variables y a la vez, asignarlas a su pin pertinente.</p>
<div id="material-1" class="section level4">
<h4>Material</h4>
<ul>
<li><p>3 leds, color indistinto</p></li>
<li><p>3 resistencias de al menos 330<span class="math inline">\(\Omega\)</span></p></li>
<li><p>Tablilla de prototipado</p></li>
<li><p>Arduino UNO</p></li>
</ul>
</div>
<div id="circuito-1" class="section level4">
<h4>Circuito</h4>
<p>Conectaremos los tres leds tal como sigue. No olvidemos que la patilla corta va hacia tierra y que la resistencia puede unirse indistintivamente a dicha conexión o a voltaje/control.</p>
<p><img src="images/091-circuito-02.png" /></p>
</div>
<div id="código-1" class="section level4">
<h4>Código</h4>
<p>Al inicio de nuestro programa podemos asignar los pines a una variable entera. Las variables se declaran como <code>(int)</code>:</p>
<pre class="{c++}"><code>int led1 = 12;
int led2 = 11;
int led3 = 10;</code></pre>
<p>Configuramos los pines como salidas:</p>
<pre class="{c++}"><code>void setup()
{
  pinMode(led1, OUTPUT);
  pinMode(led2, OUTPUT);
  pinMode(led3, OUTPUT);
}</code></pre>
<p>Crearemos ahora el programa:</p>
<pre class="{c++}"><code>void loop()
{
  digitalWrite(led1, HIGH);
  delay(1000);
  digitalWrite(led1, LOW);
  delay(500);
  digitalWrite(led2, HIGH);
  delay(1000);
  digitalWrite(led2, LOW);
  delay(500);
  digitalWrite(led3, HIGH);
  delay(1000);
  digitalWrite(led3, LOW);
  delay(500);
}</code></pre>
<p>A continuación el código completo:</p>
<pre class="{c++}"><code>int led1 = 12;
int led2 = 11;
int led3 = 10;

void setup()
{
  pinMode(led1, OUTPUT);
  pinMode(led2, OUTPUT);
  pinMode(led3, OUTPUT);
}

void loop()
{
  digitalWrite(led1, HIGH);
  delay(1000);
  digitalWrite(led1, LOW);
  delay(500);
  digitalWrite(led2, HIGH);
  delay(1000);
  digitalWrite(led2, LOW);
  delay(500);
  digitalWrite(led3, HIGH);
  delay(1000);
  digitalWrite(led3, LOW);
  delay(500);
}</code></pre>
</div>
</div>
<div id="práctica-02-con-un-ciclo-for" class="section level3">
<h3>Práctica 02 con un ciclo <em>for</em></h3>
<p>Mismo circuito, diferente implementación de código. Haremos uso de un bucle <em>for</em>:</p>
<div id="código-2" class="section level4">
<h4>Código</h4>
<pre class="{c++}"><code>int leds[3] = {12, 11, 10};

void setup()
{
  int i = 0;
  for (i=0; i&lt;3; i++)
  {
    pinMode(leds[i], OUTPUT);
  }
}

void loop()
{
  int i = 0;
  for(i=0; i&lt;3; i++)
  {
    digitalWrite(leds[i], HIGH);
    delay(500);
    digitalWrite(leds[i], LOW);
    delay(500);
  }
}</code></pre>
</div>
</div>
<div id="práctica-03.-recibiendo-señal-de-un-botón" class="section level3">
<h3>Práctica 03. Recibiendo señal de un botón</h3>
<p>En esta ocasión leeremos el estado de un botón interruptor y en consecuencia de este, encenderemos (o mantendremos apagado) un led. Hasta este momento solo hemos utilizado la función <em>digitalWrite()</em> para enviar voltaje a través de un pin desde Arduino hasta un led, encendiéndolo. Ahora utilizaremos <em>digitalRead()</em>, con la cual leeremos un nivel lógico o cambio de estado en el botón.</p>
<p><em>digitalRead()</em> es bastante simple: devolverá HIGH o 1, si el voltaje en el pin asociado es alto o existente (tomemos en cuenta que es una lectura digital, por lo cual considera voltajes mayores a 2.5V como un alto lógico); por otro lado, devolverá LOW o 0 en caso contrario.</p>
<div id="material-2" class="section level4">
<h4>Material</h4>
<ul>
<li><p>Led (color indistinto)</p></li>
<li><p>Resistencia de al menos 330<span class="math inline">\(\Omega\)</span></p></li>
<li><p>Resistencia de 1k<span class="math inline">\(\Omega\)</span></p></li>
<li><p>Botón interruptor (switch button) de 4 terminales</p></li>
<li><p>Arduino UNO</p></li>
</ul>
</div>
<div id="circuito-pull-up" class="section level4">
<h4>Circuito <em>pull-up</em></h4>
<p>Es muy importante mencionar que al configurar como entrada un pin, este se comportará como una especie de antena y estará leyendo de manera aleatoria valores HIGH o LOW, ya que no es controlado por el circuito. Esto se debe a que al estar en modo entrada, el pin se encuentra en estado de alta impedancia y sus lecturas serán flotantes. Por esta razón debemos agregar una resistencia al circuito (en circuitos comunes, un botón interruptor no la necesitaría), que le brinde una conexión por defecto al interruptor, aunque este se encuentre abierto. Sin embargo, existen dos posibles configuraciones para esto: resistencia pull-up y resistencia pull-down. Comenzaremos con la configuración pull-up:</p>
<p><img src="images/092-circuito-03.png" /></p>
<p>Podemos distinguir que en este arreglo la resistencia pull-up (notemos que el cable conectado al pin 2 se encuentra entre el botón y el resistor), crea una conexión permanente entre el pin de control y la alimentación. Esto implica que la lectura será HIGH, siempre y cuando el botón no sea presionado. Al momento de accionar el interruptor, la corriente se irá a la conexión a tierra que habilitará dicho botón, por lo que la lectura en el pin 2 ahora será LOW.</p>
<div id="código-3" class="section level6">
<h6>Código</h6>
<p>Con lo anterior expuesto, podemos saber que al utilizar una resistencia pull-up tendremos el equivalente a un botón normalmente cerrado (NC). En consecuencia, nuestro código debe expresarse aproximadamente como sigue, para aprovechar la circunstancia.</p>
<p>Primero declaremos los pines de acuerdo al componente que les conectaremos:</p>
<pre class="{c++}"><code>int boton=2; // Pin del botón
int led=13; // Pin del led</code></pre>
<p>Ahora configuramos el modo de trabajo de cada pin:</p>
<pre class="{c++}"><code>void setup() // Esto se ejecuta cada que se enciende el arduino
{
  pinMode(boton, INPUT); // configuramos el puerto como entrada
  pinMode(led, OUTPUT); // configuramos el puerto como salida
}</code></pre>
<p>Para estar verificando continuamente el estado del botón y realizar alguna acción si este cambia, utilizaremos la sentencia condicional <em>if</em>. Para esta práctica, encenderemos un led cuando el botón sea presionado, lo que implica que la condición es que el estado del interruptor sea LOW, debido a que la resistencia pull-up le da un estado HIGH por defecto.</p>
<pre class="{c++}"><code>void loop() 
{
  if (digitalRead(boton) == LOW) //con resistencia pull-up LOW significa que el botón ha sido presionado
  {
    digitalWrite(led, HIGH); //encendemos el led si detectamos el cambio de estado del interruptor
  }
  else //si el estado no cambia, entonces:
  {
    digitalWrite(led, LOW); //el led continúa apagado
  }
}</code></pre>
</div>
<div id="resistencia-pull-down" class="section level5">
<h5>Resistencia <em>pull-down</em></h5>
<p><img src="images/093-circuito-03-a.png" /></p>
<p>Aquí podemos notar que la conexión permanente es del pin 2 con tierra, por lo que dicho pin estará leyendo un LOW por defecto. Así, cuando el botón sea presionado, la corriente que viene de los 5V de alimentación se irán hacia el pin 2, cambiando el estado a HIGH. Tenemos entonces el comportamiento de un botón normalmente abierto (NA).</p>
<div id="código-4" class="section level6">
<h6>Código</h6>
<p>Prácticamente el mismo, solo con un ligero cambio:</p>
<pre class="{c++}"><code>// Declaramos los puertos de entrada y salida

int boton=2; // Pin del botón
int led=13; // Pin del led
 
// Función principal

void setup() // Esto se ejecuta cada que se enciende el arduino
{
  pinMode(boton, INPUT); // configuramos el puerto como entrada
  pinMode(led, OUTPUT); // configuramos el puerto como salida
}

// Función a repetir

void loop() // Esto se ejecuta siempre que se esté encendido
{
  if (digitalRead(boton) == HIGH) // con resistencia pull-down el estado del botón presionado es HIGH
  {
    digitalWrite(led, HIGH);
  }
  else
  {
    digitalWrite(led, LOW);
  }
}
      
// Termina el programa
</code></pre>
</div>
</div>
</div>
</div>
<div id="práctica-04.-lectura-serial-de-una-entrada-digital" class="section level3">
<h3>Práctica 04. Lectura serial de una entrada digital</h3>
<p>Reutilizaremos uno de los circuitos con un botón interruptor (arreglo pull-down), con la posibilidad de prescindir del led, pues los cambios en el estado del botón los podremos identificar mediante la salida en la consola serial (ya sea en el monitor de Tinkercad o en la pantalla de la computadora por medio del IDE de Arduino).</p>
<div id="material-3" class="section level4">
<h4>Material</h4>
<ul>
<li><p>Led (color indistinto)</p></li>
<li><p>Resistencia de al menos 330<span class="math inline">\(\Omega\)</span></p></li>
<li><p>Resistencia de 1k<span class="math inline">\(\Omega\)</span></p></li>
<li><p>Botón interruptor (switch button) de 4 terminales</p></li>
<li><p>Arduino UNO</p></li>
</ul>
</div>
<div id="código-5" class="section level4">
<h4>Código</h4>
<p>La secuencia de declaraciones y configuraciones que ya conocemos, con excepción de una línea nueva:</p>
<pre class="{c++}"><code>int boton=2;
int led=13;

void setup() 
{
  pinMode(boton,INPUT); 
  pinMode(led, OUTPUT);
  Serial.begin(9600); //Inicia la comunicación serial en el puerto 9600
}</code></pre>
<p>Para el ciclo utilizaremos lo siguiente:</p>
<ol style="list-style-type: decimal">
<li><p>Una variable entera para guardar en ella el estado del botón (0 o 1).</p></li>
<li><p>Una función nueva, <em>Serial.println(“Texto a imprimir”)</em>, la cual imprime en la consola serial.</p></li>
</ol>
<pre class="{c++}"><code>void loop() 
{
  int estado = digitalRead(boton); 
  if (estado==1) // el 1 indica que el botón ha sido presionado
  {
    Serial.println(&quot;Presionado&quot;);
    digitalWrite(led, HIGH); 
  }
  else
  {
    Serial.println(&quot;No presionado&quot;);
    digitalWrite(led, LOW);
  }
  delay(100); //Retardo para la correcta visualización en la consola
}</code></pre>
<p>El estado del botón debería estar mostrándose en el monitor serial y cambiar al ser presionado.</p>
</div>
</div>
<div id="práctica-05.-introduciendo-datos-en-la-consola-serial" class="section level3">
<h3>Práctica 05. Introduciendo datos en la consola serial</h3>
<p>Ya hemos visto cómo disparar eventos mediante un botón y también cómo leer el estado de dicho componente en la consola serial. Ahora utilizaremos la consola para leer un caracter introducido por el usuario, con la finalidad de disparar un evento dependiendo de cuál caracter se ha introducido. Específicamente hablando, encenderemos un led al introducir un ‘1’ en la consola, apagándolo si introducimos un ‘0’.</p>
<div id="material-4" class="section level4">
<h4>Material</h4>
<ul>
<li><p>Led de color indistinto</p></li>
<li><p>Resistencia de 220<span class="math inline">\(\Omega\)</span></p></li>
<li><p>Arduino UNO</p></li>
</ul>
</div>
<div id="circuito-2" class="section level4">
<h4>Circuito</h4>
<p>De lo más sencillo que hemos realizado, ya que solo estaremos encendiendo/apagando el led:</p>
<p><img src="images/088-circuito-01.png" /></p>
</div>
<div id="código-6" class="section level4">
<h4>Código</h4>
<p>Agregaremos expresiones no utilizadas anteriormente, como la declaración de dos variables, una tipo <em>char</em>, la cual almacenará el último caracter introducido en la consola serial (el tipo <em>char</em> solo almacena un caracter ASCII a la vez), y otra tipo <em>boolean</em> donde estaremos almacenando el estado del led (si se encuentra encendido sera <em>true</em>, apagado será <em>false</em>):</p>
<pre class="{c++}"><code>int led = 13; //Pin donde se encuentra el led, salida
char lectura; //Variable donde se almacena la letra
boolean encendido = false; //Estado del led la primera vez, apagado por defecto</code></pre>
<p>En la configuración abrimos la comunicación serial a la vez que configuramos el pin 13 como salida:</p>
<pre class="{c++}"><code>void setup() 
{
  Serial.begin(9600); //Inicia comunicación serial
  pinMode(led, OUTPUT); 
}</code></pre>
<p>Ya en la función principal haremos la lectura de la consola serial y guardaremos su valor en la variable tipo <em>char</em> que ya declaramos. Así, si el valor introducido es un ‘1’ y el led está apagado, lo encendemos y guardamos su estado. Por lo contrario, si se introduce un ‘0’ y el led está encendido, lo apagamos y también actualizamos su estado. Esto lo conseguiremos con un condicional <em>if</em> que incluya el operador <em>and</em> para que considere el cumplimiento de ambas condiciones a la vez:</p>
<pre class="{c++}"><code>void loop()
{
  lectura=Serial.read();
  if ( (lectura == &#39;1&#39;) &amp;&amp; (encendido == false) ) // Si es &#39;1&#39; y además el led está apagado
  {
    digitalWrite(led, HIGH); // Encendemos el led
    encendido = true; // Actualizamos el estado del led
  }
  else if ( (lectura == &#39;0&#39;) &amp;&amp; (encendido == true) ) // Si es &#39;0&#39; y además el led está encendido
  {
    digitalWrite(led, LOW); // Apagamos el led
    encendido = false; // Actualizamos el estado del led
  }
}</code></pre>
</div>
</div>
<div id="práctica-06.-encender-gradualmente-un-led" class="section level3">
<h3>Práctica 06. Encender gradualmente un led</h3>
<p>Hasta el momento no hemos utilizado la funcionalidad PWM, la cual nos permite dar una salida análoga para el control de ciertos componentes. Este tipo de salida resulta muy útil cuando queramos que un componente tenga un comportamiento cambiante más allá de lo que una salida digital brinda: solo encender y apagar. En nuestro caso, comenzaremos por darle a un led un incremento gradual en su brillo, utilizando uno de los tantos pines PWM del arduino. Estos últimos los podemos identificar por medio de la virgulilla (~) que acompaña al número de pin.</p>
<div id="material-5" class="section level4">
<h4>Material</h4>
<ul>
<li><p>Led de color indistinto, rojo de preferencia</p></li>
<li><p>Resistencia de al menos 220<span class="math inline">\(\Omega\)</span></p></li>
<li><p>Arduino UNO</p></li>
</ul>
</div>
<div id="circuito-3" class="section level4">
<h4>Circuito</h4>
<p>Es un arreglo muy sencillo, ya quie consiste solo de un led y una resistencia. Sin embargo, no conectaremos el led al mismo pin 13 de siempre, ya que necesitamos un pin con salida análoga. Usaremos para este caso el pin 9:</p>
<p><img src="images/094-circuito-05-a.png" /></p>
</div>
<div id="código-7" class="section level4">
<h4>Código</h4>
<p>Declararemos una variable que represente al brillo actual del led, el cual debe arrancar en cero. A la vez introduciremos una variable que represente al incremento gradual del brillo, en este caso será de 5 en 5:</p>
<pre class="{c++}"><code>int brillo = 0;
int variacion = 5;
int led = 9; </code></pre>
<p>Configuramos el único pin utilizado como salida:</p>
<pre class="{c++}"><code>void setup () 
{
  pinMode(led, OUTPUT); 
}</code></pre>
<p>Utilizaremos la función <em>analogWrite</em> en lugar de la habitual <em>digitalWrite</em> para encender proporcionalmente al led. Notemos que la primera tiene como segundo argumento un valor que no necesariamente se corresponde con LOW o HIGH. Este puede ser cualquier valor entre 0 y 255. En nuestro caso, comenzará como 0, ya que usaremos la variable <em>brillo</em> declarada anteriormente. Para conseguir que en cada vuelta del ciclo el brillo aumente, agregamos una línea que incrementa el valor de <em>brillo</em> sumándole el valor de la variable <em>variacion</em>: 5 cada vez. Luego, recordando que los valores mínimo y máximo de una salida PWM son 0 y 255, respectivamente, procedemos a introducir una condición a cumplir. Si el led se encuentra totalmente encendido o totalmente apagado cambiamos el signo de la variable <em>variacion</em> para invertir el sentido del incremento.</p>
<p>Por ejemplo, al inicio el led arranca totalmente apagado, pero obtiene casi de inmediato un incremento de 5 (debido a la segunda línea del ciclo <em>loop</em>), por lo que irá incrementando de 5 en 5 hasta que llegue a 255: brillo pleno. En este punto cambiamos el signo de <em>variacion</em> que entonces se comportará como decremento ya que se estará restando al valor actual de <em>brillo</em>, hasta que llegue a 0. En este punto, totalmente apagado, volvemos a cambiar el signo de <em>variacion</em>, volviéndose positiva e implicar de nuevo un incremento al estarse sumando a <em>brillo</em>:</p>
<pre class="{c++}"><code>void loop ()
{
  analogWrite(led, brillo); // Escritura análoga (PWM) en el led, se escribe el valor actual de brillo
  brillo = brillo + variacion; // Incrementamos la variable brillo de 5 en 5
  if (brillo == 0 || brillo == 255)
    variacion = -variacion; //La variación cambia de sentido
    delay (30); //Tiempo de incremento en el brillo
}</code></pre>
</div>
</div>
<div id="práctica-07.-introduciendo-un-potenciómetro" class="section level3">
<h3>Práctica 07. Introduciendo un potenciómetro</h3>
<p>Un potenciómetro es una resistencia variable, cuya variación es controlada por medio de una perilla. Esta última aumenta la resistencia conforme se mueva hacia la izquierda, haciendo lo contrario en la dirección opuesta. Como puede intuirse, un potenciómetro (o pot, como tradicionalmente se le llama para abrebiar), es un componente análogo, por lo cual debe ser conectado a un pin que admita este tipo de entrada. Para esta práctica leeremos el valor de la resistencia del pot y lo mostraremos en la consola serial.</p>
<div id="material-6" class="section level4">
<h4>Material</h4>
<ul>
<li><p>Potenciómetro de 10k<span class="math inline">\(\Omega\)</span></p></li>
<li><p>Arduino UNO</p></li>
</ul>
</div>
<div id="circuito-4" class="section level4">
<h4>Circuito</h4>
<p>Conectaremos el pot de la siguiente manera. Notemos que la alimentación de 5V se conecta a la tercera terminal, mientras que la tierra se une a la primera patilla. La señal del pot se corresponde con la terminal de enmedio, y la conectamos al pin analógico A0.</p>
<p><img src="images/095-circuito-06-a.png" /></p>
</div>
<div id="código-8" class="section level4">
<h4>Código</h4>
<p>No declararemos ninguna variable al inicio del código, lo haremos justo en el ciclo de trabajo. Abrimos la comunicación serial a 9600 en la configuración y pasamos al ciclo. En el ciclo declaramos la variable donde almacenaremos la lectura en el pin analógico, imprimimos dicho valor en la consola y colocamos un retraso en la visualización de los datos.</p>
<pre class="{c++}"><code>void setup()
{
  Serial.begin(9600);
}

void loop() 
{
  int valor= analogRead(A0);
  Serial.println(valor);
  delay(100);
}</code></pre>
</div>
</div>
<div id="práctica-08.-encendiendo-un-led-con-el-pot" class="section level3">
<h3>Práctica 08. Encendiendo un led con el pot</h3>
<p>El circuito anterior resultó ser bastante sencillo, pues solo necesitamos el pot y la placa para hacerlo funcionar. Ahora veremos como encender un led, dependiendo de la lectura de la posición que tenga la perilla del pot. No olvidemos que esta lectura se encuentra entre 0 y 1023. Como puede observarse, el led seguirá comportándose como un componente digital, por ende, solo encenderá y apagará.</p>
<div id="material-7" class="section level4">
<h4>Material</h4>
<ul>
<li><p>Potenciómetro de 10k<span class="math inline">\(\Omega\)</span></p></li>
<li><p>Led de cualquier color</p></li>
<li><p>Resistencia de 220<span class="math inline">\(\Omega\)</span></p></li>
<li><p>Arduino UNO</p></li>
<li><p>Tablilla de prototipado</p></li>
</ul>
</div>
<div id="circuito-5" class="section level4">
<h4>Circuito</h4>
<p>A partir de ahora haremos uso extensivo de la tablilla de prototipado, para mantener cierta organización coherente de los diferentes dispositivos conectados. La disposición de las terminales del potenciómetro es la misma que en el circuito anterior, solo que ahora la conectamos mediante la tablilla. Agregamos el led y su resistencia, respetando la polaridad de este:</p>
<p><img src="images/096-circuito-07.png" /></p>
</div>
<div id="código-9" class="section level4">
<h4>Código</h4>
<p>Comenzamos declarando el pin conectado al led y configurándolo como salida en el <em>setup()</em>, además de abrir allí mismo la comunicaci+on serial:</p>
<pre class="{c++}"><code>int led = 13;

void setup() 
{
  Serial.begin(9600); 
  pinMode(led, OUTPUT);
}</code></pre>
<p>Enseguida pasamos a construir el ciclo de trabajo. Este consistirá de los siguientes pasos:</p>
<ol style="list-style-type: decimal">
<li><p>Obtener la lectura en el pin A0 y asignarla a una variable (le llamaremos valor);</p></li>
<li><p>Imprimir dicha variable en la consola serial;</p></li>
<li><p>Introducir una condición: si la perilla se encuentra en la mitad derecha de su giro total, el led encenderá. En caso contrario, se apagará.</p></li>
<li><p>Ponemos un retraso para la visualización de los datos en la consola.</p></li>
</ol>
<pre class="{c++}"><code>void loop()
{
  int valor = analogRead(A0); 
  Serial.println(valor); 
  if (valor &gt;= 511) 
  {
    digitalWrite(led,HIGH); 
  }
  else 
  {
    digitalWrite(led,LOW); 
  }
delay(100);
}</code></pre>
<p>Sabemos que todo el giro de la perilla se corresponde con un espectro de valores de entrada analógica que va desde 0 hasta 1023. Por lo tanto, la mitad de dicho giro se encuentra en el 511. Colocamos este valor en la condicional para obligar al cambio de estado del led justo cuando la perilla alcance la mitad del giro total. El código completo se muestra a continuación:</p>
<pre class="{c++}"><code>int led = 13;

void setup() 
{
  Serial.begin(9600); 
  pinMode(led, OUTPUT);
}

void loop()
{
  int valor = analogRead(A0); //Guardar el valor de la lectura análoga
  Serial.println(valor); //Imprime el valor por la consola
  if (valor &gt;= 500) //Si el valor es mayor o igual a 500
  {
    digitalWrite(led,HIGH); //Enciende el LED en el pin 13
  }
  else //Si el valor es menor a 500
  {
    digitalWrite(led,LOW); //Apaga el LED en el pin 13
  }
delay(100); //Retardo de 100ms para ver los datos de la consola
}</code></pre>
</div>
</div>
<div id="práctica-09.-encendido-gradual-de-un-led-con-el-giro-de-un-pot" class="section level3">
<h3>Práctica 09. Encendido gradual de un led con el giro de un pot</h3>
<p>Encender un led dependiendo de la posición de la perilla de un pot no resulta ser demasiado práctico. En todo caso no estaríamos utilizando el potenciómetro como se debe, ya que esta tarea la puede realizar también un simple botón interruptor. Resulta pues, más adecuado variar el brillo del led de manera proporcional al giro de la perilla del pot. Eso es lo que implementaremos ahora. Necesitaremos:</p>
<div id="material-8" class="section level4">
<h4>Material</h4>
<ul>
<li><p>Potenciómetro de 10k<span class="math inline">\(\Omega\)</span></p></li>
<li><p>Led de cualquier color</p></li>
<li><p>Resistencia de 220<span class="math inline">\(\Omega\)</span></p></li>
<li><p>Arduino UNO</p></li>
<li><p>Tablilla de prototipado</p></li>
</ul>
</div>
<div id="circuito-6" class="section level4">
<h4>Circuito</h4>
<p>Prácticamente el mismo que el anterior, con la única diferencia de que cambiaremos el pin donde conectamos el led. En este caso, queremos utilizar una salida analógica, por ello haremos uso del pin 11 (PWM):</p>
<p><img src="images/097-circuito-08.png" /></p>
</div>
<div id="código-10" class="section level4">
<h4>Código</h4>
<p>Debemos declarar más variables que en la práctica anterior: una primera para el pin del led, una segunda para el pin del pot, una tercera para almacenar el valor de la lectura del pot y una última para almacenar el valor a enviar al led (estas dos pultimas incializadas en 0). ¿Por qué no simplemente mandamos la señal de la lectura del pot directamente al led? Porque necesitamos «convertirla» de manera proporcional. Recordemos que las lecturas análogas van desde 0 hasta 1023, pero las salidas análogas tienen un espectro más reducido: de 0 a 255. Para convertirla, pasaremos el valor de la señal del pot a través de la función <em>map</em>, la cual hará la conversión pertinente.</p>
<pre class="{c++}"><code>int pot = A0; 
int led = 11; 
int ValorPot = 0;
int ValorLed = 0;</code></pre>
<p>Abrimos la comunicación serial:</p>
<pre class="{c++}"><code>void setup() 
{
  Serial.begin(9600); 
}</code></pre>
<p>Y ahora pasamos al ciclo de trabajo. Asignamos la lectura análoga del pot a la variable destinada (<em>ValorPot</em>), luego la mapeamos para hacerla proporcional al rango de valores de salida analógica. Obeservemos los argumentos a dar a la función <em>map</em>: <em>map(variable_a_mapear, valor_a_mapear_inicial, valor_a_mapear_final, valor_mapeado_inicial, valor_mapeado_final)</em>.</p>
<p>Asignamos el resultado de este mapeado en la variable correspondiente (<em>ValorLed</em>) y la escribimos en el pin del led. Hasta ahí ya tenemos todo lo necesario para encender el led de manera gradual. Lo siguiente es solamente para poder mostrar los valores de ambas variables mediante texto más o menos formateado en la consola serial.</p>
<pre class="{c++}"><code>void loop() 
{
  ValorPot = analogRead(pot);
  ValorLed = map(ValorPot, 0, 1023, 0, 255);
  analogWrite(led, ValorLed); 
  Serial.print(&quot;Valor del sensor = &quot; ); // imprimimos esta frase en la consola
  Serial.print(ValorPot); // imprimimos justo enseguida el valor de la señal del pot
  Serial.print(&quot;\t Intensidad de brillo = &quot;); // otra frase, ahora con tabulación
  Serial.println(ValorLed); // imprimimos el valor de salida, cerrando línea y pasando a otra
  delay(2); // esperamos dos milisegundos para dar tiempo a la correcta conversión
}</code></pre>
<p>A continuación el código completo:</p>
<pre class="{c++}"><code>const int pot = A0;
const int led = 11;
int ValorPot = 0; 
int ValorLed = 0; 

void setup() 
{
  Serial.begin(9600);
}

void loop() 
{
  ValorPot = analogRead(pot);
  ValorLed = map(ValorPot, 0, 1023, 0, 255);
  analogWrite(led, ValorLed);
  Serial.print(&quot;Valor del sensor = &quot; ); 
  Serial.print(ValorPot);
  Serial.print(&quot;\t Intensidad de brillo = &quot;);
  Serial.println(ValorLed);
  delay(2);
}</code></pre>
</div>
</div>
<div id="práctica-10.-encendiendo-un-motor-cd" class="section level3">
<h3>Práctica 10. Encendiendo un motor CD</h3>
<p>Los motores eléctricos son dispositivos que transforman la energía eléctrica en movimiento, gracias a ciertos fenómenos electromagnéticos. Existen varios tipos de motor eléctrico que podemos dividir en dos categorías muy notorias, basados en el tipo de corriente que los energiza: corriente alterna y corriente directa. Nos enfocaremos en los últimos. Estos son relativamente fáciles de controlar en cuanto a su velocidad y sentido del giro: variando el voltaje para lo primero, invirtiendo la polaridad para lo segundo.</p>
<p>Sin embargo, es importante mencionar que un motor eléctrico es también un dispositivo reversible: si se alimenta con energía eléctrica en sus terminales produce movimiento en un eje, pero si ese eje se mueve por medios externos entonces generará una corriente eléctrica en esas mismas terminales.</p>
<div id="materiales" class="section level4">
<h4>Materiales</h4>
<ul>
<li><p>Transistor NPN (BJT)</p></li>
<li><p>Resistencia de 2.2 k<span class="math inline">\(\Omega\)</span></p></li>
<li><p>Diodo</p></li>
<li><p>Motor de corriente directa o continua</p></li>
<li><p>Tablilla de prototipado</p></li>
<li><p>Arduino UNO</p></li>
</ul>
</div>
<div id="circuito-7" class="section level4">
<h4>Circuito</h4>
<p>No podemos simplemente conectar el motor al arduino por dos razones importantes: un motor es un componente que requiere bastante energía y el hecho de que puede producir una corriente eléctrica si se hace girar su eje por medios externos, corriendo el riesgo de dañar el arduino. Lo primero se sobrelleva con el transistor incluido en la lista de materiales, ya que le estaremos dando uso como si fuera un interruptor controlado electrónicamente (mediante una señal proveniente del arduino abriremos o cerramos el circuito interno); mientras que lo segundo se resuelve con el diodo, el cual es un componente electrónico que solo permite el flujo eléctrico en una sola dirección, bloqueando la posible corriente que venga del motor con algún giro residual.</p>
<p>El arreglo adecuado para proteger el circuito de las corrientes que puedan generarse en el motor por algún movimiento residual de su eje se presenta a continuación:</p>
<p><img src="images/098-circuito-10.png" /></p>
</div>
<div id="código-11" class="section level4">
<h4>Código</h4>
<p>El código es totalmente compatible con los ya utilizados para controlar leds, pudiendo incluso utilizar el que viene por defecto en el arduino, siempre y cuando conectemos el motor al pin 13. En este caso lo hemos conectado al 9, así que hicimos el cambio pertinente:</p>
<pre class="{c++}"><code>int motor = 9;
void setup() 
{
  pinMode(motor, OUTPUT);
}
void loop() 
{
  digitalWrite(motor, HIGH);
  delay(1000);
  digitalWrite(motor, LOW);
  delay(1000);
}</code></pre>
<p>El motor encenderá y apagará en intervalos de un segundo.</p>
</div>
</div>
<div id="práctica-11.-controlando-un-motor-cd-con-un-potenciómetro" class="section level3">
<h3>Práctica 11. Controlando un motor CD con un potenciómetro</h3>
<p>Al igual que como se hizo con el incremento gradual del brillo de un led, regulado por la perilla de un potenciómetro, es posible controlar la velocidad de giro de un motor de corriente directa. En este caso, la velocidad será proporcional a la posición de la perilla.</p>
<div id="material-9" class="section level4">
<h4>Material</h4>
<ul>
<li><p>Transistor NPN (BJT)</p></li>
<li><p>Resistencia de 2.2 k<span class="math inline">\(\Omega\)</span></p></li>
<li><p>Diodo</p></li>
<li><p>Motor de corriente directa o continua</p></li>
<li><p>Potenciómetro</p></li>
<li><p>Tablilla de prototipado</p></li>
<li><p>Arduino UNO</p></li>
</ul>
</div>
<div id="circuito-8" class="section level4">
<h4>Circuito</h4>
<p>Ya se mencionó anteriormente la razón de incluir un transistor y un diodo. Así que reutilizamos el mismo circuito de la práctica anterior, con la salvedad de que agregaremos un pot.</p>
<p><img src="images/099-circuito-11.png" /></p>
</div>
<div id="código-12" class="section level4">
<h4>Código</h4>
<p>Considerando la obvia excepción del circuito, controlar un motor de corriente directa es prácticamente igual que hacerlo con un led. Por esa razón, el código es bastante similar a la práctica 09.</p>
<pre class="{c++}"><code>int pot = A0; // pin del pot
int motor = 9; // pin del motor
int valorpot = 0; // valor de entrada del pot
int valormotor = 0; // valor de salida al motor

void setup() 
{
  Serial.begin(9600);
}

void loop() 
{
  valorpot = analogRead(pot); // leemos al pot
  valormotor = map(valorpot, 0, 1023, 0, 255); // mapeamos dicha lectura
  analogWrite(motor, valormotor); // enviamos el valor mapeado al motor
  Serial.print(&quot;Lectura del pot = &quot; );
  Serial.print(valorpot);
  Serial.print(&quot;\t motor = &quot;);
  Serial.println(valormotor); // imprimimos ambos valores en consola
  delay(2);
}</code></pre>
</div>
</div>
<div id="práctica-12.-encender-un-led-en-ausencia-de-luz" class="section level3">
<h3>Práctica 12. Encender un led en ausencia de luz</h3>
<p>La manera más sencilla de detectar la presencia de iluminación es mediante una fotorresistencia, la cual es una resistencia que varía de manera proporcional a la cantidad de luz que incide sobre la misma. En esta práctica encenderemos un led de manera proporcional a la cantidad de luz en el ambiente.</p>
<div id="material-10" class="section level4">
<h4>Material</h4>
<ul>
<li><p>Led rojo</p></li>
<li><p>Resistencia de 220<span class="math inline">\(\Omega\)</span> y de 10k<span class="math inline">\(\Omega\)</span></p></li>
<li><p>Fotorresistencia</p></li>
<li><p>Tablilla de prototipado</p></li>
<li><p>Arduino UNO</p></li>
</ul>
</div>
<div id="circuito-9" class="section level4">
<h4>Circuito</h4>
<p>Es un circuito bastante simple, utilizaremos el típico que corresponde a un led. Lo adicional será la fotorresistencia y una resistencia común de 10k<span class="math inline">\(\Omega\)</span>.</p>
<p><img src="images/100-circuito-12.png" /></p>
</div>
<div id="código-13" class="section level4">
<h4>Código</h4>
<p>El código también es bastante sencillo. Asignamos un nombre al pin donde conectamos el led y crearemos dos variables. En estas almacenaremos la lectura análoga del sensor y la señal con PWM que se enviará al led. La lógica del ciclo de trabajo es similar a algunas anteriores: obtener la lectura analógica del sensor, hacerla proporcional a la señal de salida y escribir esta en el pin del led. Notemos que el comportamiento por defecto de la fotorresistencia es apagar el led en ausencia de luz, pero la intención es que haga lo contrario. Para conseguir el efecto deseado, solo invertimos el mapeado, asignando el valor resultante de 0 para que corresponda con el 1023 de entrada:</p>
<pre class="{c++}"><code>int led = 9;
int valorfoto = 0;
int valorled = 0;

void setup()
{
  pinMode(led, OUTPUT);
}

void loop()
{
  valorfoto = analogRead(A0);
  valorled = map(valorfoto, 0, 1023, 255, 0);
  analogWrite(led, valorled);
  delay(10);
}</code></pre>
</div>
</div>
<div id="práctica-13.-detectando-movimiento" class="section level3">
<h3>Práctica 13. Detectando movimiento</h3>
<p>Para detectar movimiento se utiliza un sensor PIR. Este sensor no detecta objetos u obstáculos, a menos que estos se muevan. El circuito resulta ser muy sencillo.</p>
<div id="material-11" class="section level4">
<h4>Material</h4>
<ul>
<li><p>Sensor PIR</p></li>
<li><p>Led de cualquier color</p></li>
<li><p>Resistencia de 220 <span class="math inline">\(\Omega\)</span></p></li>
<li><p>Tablilla de prototipado</p></li>
<li><p>Arduino UNO</p></li>
</ul>
</div>
<div id="circuito-10" class="section level4">
<h4>Circuito</h4>
<p><img src="images/101-circuito-13.png" /></p>
<p>Como podemos observar, el sensor no requiere componentes adicionales. Solo se conecta al arduino respetando la polaridad de sus terminales. El led solo funciona como la prueba de que se ha detectado movimiento y no es realmente necesario.</p>
</div>
<div id="código-14" class="section level4">
<h4>Código</h4>
<pre class="{c++}"><code>const int led = 13;
const int pir = 2;
 
void setup()
{
  pinMode(led, OUTPUT);
  pinMode(pir, INPUT);
}
 
void loop()
{
  int valorpir= digitalRead(pir);
 
  if (valorpir == HIGH)
  {
    digitalWrite(led, HIGH);
    delay(500);
    digitalWrite(led, LOW);
    delay(500);
  }
  else
  {
    digitalWrite(led, LOW);
  }
}</code></pre>
</div>
</div>
<div id="práctica-14.-midiendo-distancias" class="section level3">
<h3>Práctica 14. Midiendo distancias</h3>
<p>Como ya vimos, el PIR solo detecta movimiento. Si quisiéramos detectar obstáculos (para poder evitarlos o determinar la distancia a la que se encuentran) debemos utilizar un sensor ultrasónico. Este funciona como el sonar de los muerciélagos, enviando pulsos ultrasónicos y calculando la distancia a la que se encuentran los objetos tras medir el tiempo que toma el eco del sonido en regresar.</p>
<div id="material-12" class="section level4">
<h4>Material</h4>
<ul>
<li><p>Sensor ultrasónico HC-SR04</p></li>
<li><p>Tablilla de prototipado</p></li>
<li><p>Arduino UNO</p></li>
</ul>
</div>
<div id="circuito-11" class="section level4">
<h4>Circuito</h4>
<p>Muy sencillo, solo hay que cuidar la polaridad de las terminales del sensor, el cual no necesita ningún componente adicional.</p>
<p><img src="images/102-circuito-14.png" /></p>
</div>
<div id="código-15" class="section level4">
<h4>Código</h4>
<pre class="{c++}"><code>const int pinEcho = 12; // pin del eco
const int pinTrigger = 13; // pin del disparo
 
void setup() 
{
  Serial.begin(9600);
  pinMode(pinTrigger, OUTPUT);
  pinMode(pinEcho, INPUT);
}
 
void loop() 
{
  int cm = ping(pinTrigger, pinEcho);
  Serial.print(&quot;Distancia: &quot;);
  Serial.println(cm);
  delay(1000);
}
 
int ping(int pinTrigger, int pinEcho) 
{
  long duration, distanceCm;
  digitalWrite(pinTrigger, LOW);  //generamos un pulso limpio «apagando»
  delayMicroseconds(4);
  digitalWrite(pinTrigger, HIGH);  //generamos un disparo
  delayMicroseconds(10);
  digitalWrite(pinTrigger, LOW);
  
  duration = pulseIn(pinEcho, HIGH);  //medimos el tiempo entre pulsos, en microsegundos
  distanceCm = duration * 10 / 292/ 2;   //convertimos a distancia, en cm
  return distanceCm;
}</code></pre>
</div>
</div>
<div id="práctica-15.-pantallas-lcd" class="section level3">
<h3>Práctica 15. Pantallas LCD</h3>
<p>El conjunto de conexiones necesarias para la pantalla LCD de 16x2 sí resulta algo laborioso, ya que son bastantes y de cuidado. A continuación mostramos lo necesario para armarlo.</p>
<div id="material-13" class="section level4">
<h4>Material</h4>
<ul>
<li><p>Potenciómetro</p></li>
<li><p>Resistencia de 220<span class="math inline">\(\Omega\)</span></p></li>
<li><p>Pantalla LCD 16x2</p></li>
<li><p>Tablilla de prototipado</p></li>
<li><p>Arduino UNO</p></li>
</ul>
</div>
<div id="circuito-12" class="section level4">
<h4>Circuito</h4>
<p>Utilizaremos una LCD de 16 columnas y 2 renglones. El pot se incluye para controlar el brillo de la pantalla.</p>
<p><img src="images/103-circuito-15.png" /></p>
</div>
<div id="código-16" class="section level4">
<h4>Código</h4>
<p>Se muestra el código para mostrar el clásico «hola mundo» y un contador del tiempo que lleva activo. Debe agregarse la librería correspondiente.</p>
<pre class="{c++}"><code>#include &lt;LiquidCrystal.h&gt;

const int filas = 2; // declaramos el número de filas o renglones
const int columnas = 16; // declaramos el número de columnas 
// declaramos los pines a utilizar para la interfaz
LiquidCrystal lcd(12, 11, 5, 4, 3, 2);

void setup()
{
  lcd.begin(columnas, filas);
  lcd.print(&quot;hola mundo!&quot;); // Imprimimos el mensaje
}

void loop()
{
// Llevamos el cursor a la columna 0, fila 1
// (se comienza a contar desde 0):
lcd.setCursor(0, 1);
lcd.print(millis()/1000);// Imprimimos el tiempo de actividad
}</code></pre>
</div>
</div>
</div>




</div>

<script>

// add bootstrap table styles to pandoc tables
function bootstrapStylePandocTables() {
  $('tr.odd').parent('tbody').parent('table').addClass('table table-condensed');
}
$(document).ready(function () {
  bootstrapStylePandocTables();
});


</script>

<!-- tabsets -->

<script>
$(document).ready(function () {
  window.buildTabsets("TOC");
});

$(document).ready(function () {
  $('.tabset-dropdown > .nav-tabs > li').click(function () {
    $(this).parent().toggleClass('nav-tabs-open');
  });
});
</script>

<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
